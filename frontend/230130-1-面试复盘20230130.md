# 面试复盘 20230130

## 自我介绍

1. 我是谁
2. 工作年限
3. 确定岗位（electron 开发）
4. 我的优势
   1. 成功开发过多个项目，详细的内容在我的简历
   2. nodejs
   3. 行业资源
5. 岗位要求？

## **面试提问**

## 1. 什么是 BFC

https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context

块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

## 2. grid 和 flex 布局介绍一下

Grid 布局：是 CSS 中的网格布局技术，可以将一个页面划分为行和列，便于控制元素的位置和大小。

Flex 布局：是 CSS 中的弹性布局技术，可以让一个容器中的元素自动按照一定的比例分配空间，并且可以方便地实现水平或垂直方向的布局。

## 3. grid 3 等份怎么做

## 4. CSS 有一个元素被挤压了怎么办？

## 5. 什么是重绘和回流？

CSS 的重绘（Repaint）和回流（Reflow）是指浏览器如何处理网页的布局和渲染。

重绘是指当样式的改变不影响布局时，浏览器仅更新元素的外观，例如颜色，边框和阴影。

回流是指当元素的尺寸，位置或其他属性发生更改时，浏览器需要重新计算元素的布局。这可能导致其他元素的位置或大小更改，因此，回流是需要花费更多时间的。

注意：避免不必要的重绘和回流可以提高网页的性能。

**更详细一点**

回流（Reflow）：当页面上的元素尺寸，位置，结构或其他因素改变时，浏览器必须重新计算整个文档的布局。这就是所谓的回流。因此，回流可能导致整个文档的重新渲染。

重绘（Repaint）：当元素的样式更改而不影响布局时，浏览器将对该元素进行重绘。例如，当更改元素的颜色时，浏览器将进行重绘，因为它不会改变布局，但仍然需要更新元素的外观。

两者的区别：回流涉及到布局的整个文档，可能导致性能问题，因此应该尽量避免。相比之下，重绘只影响单个元素，因此它通常不会导致性能问题。

注意：通过使用优化技巧，如将动画分离到单独的层或使用缓存，可以减少不必要的重绘和回流，从而提高页面的性能。

**哪些 CSS 属性会导致重绘和回流**

下列 CSS 属性可能会导致回流（Reflow）：

- 宽度（width）和高度（height）
- 内外边距（margin，padding）
- 边框（border）
- 字体（font）大小，类型和样式
- 行高（line-height）
- 文本对齐（text-align）
- 定位（position）
- 浮动（float）
- 显示（display）

下列 CSS 属性可能会导致重绘（Repaint）：

- 颜色（color）
- 背景颜色（background-color）
- 阴影（box-shadow）
- 透明度（opacity）
- 文本阴影（text-shadow）
- 背景图像（background-image）

## 6. 什么是跨域

跨域（Cross-Origin Resource Sharing）是指在浏览器中，同一个域名（即域名、协议、端口三者相同）的页面可以相互请求，但跨域的页面之间则不能。这种限制是浏览器安全机制的一部分，为了避免第三方网站获取敏感数据。

例如：

一个页面是从"example.com"请求"api.example.com/data"的数据，如果不存在跨域允许，则请求将被拒绝。
可以使用以下方法解决跨域问题：

使用 CORS（Cross-Origin Resource Sharing）
使用代理服务器
使用 JSONP（JSON with Padding）
使用 PostMessage API

跨域（Cross-Origin Resource Sharing）是指在浏览器中，同一个域名（即域名、协议、端口三者相同）的页面可以相互请求，但跨域的页面之间则不能。这种限制是浏览器安全机制的一部分，为了避免第三方网站获取敏感数据。

例如：

一个页面是从"example.com"请求"api.example.com/data"的数据，如果不存在跨域允许，则请求将被拒绝。
可以使用以下方法解决跨域问题：

使用 CORS（Cross-Origin Resource Sharing）
使用代理服务器
使用 JSONP（JSON with Padding）
使用 PostMessage API

解决跨域的方法中：

- CORS (Cross-Origin Resource Sharing)是一种 W3C 标准，允许 Web 应用程序通过添加 HTTP 头部在不同的域之间进行数据交换。
- 使用代理服务器是一种将请求重定向到代理服务器的方法，该代理服务器再将请求转发到目标服务器。
- JSONP (JSON with Padding)是一种特殊的跨域技术，允许在不同域之间进行数据交换。
- PostMessage API 是一种在不同窗口、标签页或域之间进行通信的 API，可以解决跨域问题。

<a href="/#/frontend/230109-2-前端跨域-简单易懂的跨域解决方案" target="_blank">前端跨域-简单易懂的跨域解决方案</a><br/>

## 7. 同一个域名，通过 IP 会导致跨域吗？

比如说:example.com 域名解析的 IP 是 123.1.1.1 ， 我在 example.com 页面上面直接请求 123.1.1.1/api 获取数据 会导致跨域吗

是的，如果你在 example.com 页面中通过请求 123.1.1.1/api 获取数据，那么将导致跨域。在浏览器中，域名、协议、端口三者都必须相同才能避免跨域。请求 123.1.1.1/api 与请求 example.com 不同，因此将导致跨域。

## 8. js 事件模型，点击事件触发过程

JS 事件模型点击事件详细过程如下：

- 用户点击某个 HTML 元素，例如一个按钮。
- 浏览器从内到外（从最里层元素到最外层元素）捕获点击事件。
- 浏览器检查该元素是否有绑定了点击事件处理函数。
- 如果该元素有绑定点击事件处理函数，浏览器调用该函数，并向其传递事件对象。
- 事件对象包含有关点击事件的信息，例如事件类型、事件发生的元素、事件发生的时间等。
- 如果该元素有父元素，浏览器继续向上冒泡，并检查父元素是否有绑定点击事件处理函数。
- 如果父元素有绑定点击事件处理函数，则调用该函数，并向其传递事件对象。
- 冒泡过程继续进行，直到到达文档的根节点为止。
- 在冒泡阶段结束后，浏览器进入捕获阶段，从外到内检查是否有元素绑定了点击事件处理函数。
- 如果存在绑定点击事件处理函数的元素，则调用该函数，

## 9. 浏览器的缓存机制都有哪些

比如：在 chrome 浏览器打开一个 html 加载 一个网页，缓存机制都有哪些

主要的浏览器缓存机制有：

- HTTP 缓存（Expires/Max-Age headers, Last-Modified/ETag headers)
- 浏览器缓存（Cache-Control headers, localStorage, sessionStorage）

当浏览器加载一个 HTML 页面时，它会使用上述缓存机制缓存页面的资源（图像、样式表、脚本等），以便在后续请求中较快地加载页面。

浏览器的缓存机制主要有以下几种：

- 1. Memory Cache：存储在浏览器内存中的临时缓存。
- 2. Disk Cache：存储在浏览器硬盘上的永久缓存。
- 3. In-Memory IndexedDB：使用 IndexedDB 数据库存储的离线缓存。
- 4. Service Worker Cache：使用 Service Worker API 存储的离线缓存。
- 5. Application Cache：使用 HTML5 的 Application Cache API 存储的离线缓存。
- 6. HTTP Cache：存储在服务器或代理上的永久缓存。

这些缓存机制都可以加快浏览器加载页面的速度，减少请求资源的数量，提高用户体验。

浏览器的缓存机制具体如下：

1. Memory Cache：存储在浏览器内存中的临时缓存。该缓存主要用于提高页面的访问速度，并在用户关闭浏览器后清除。它可以存储 HTML、CSS、JavaScript 文件等静态资源，使得页面加载速度更快。

2. Disk Cache：存储在浏览器硬盘上的永久缓存。该缓存在浏览器关闭后仍然存在，并在下次访问页面时被使用。它可以存储静态资源，以及 HTML、CSS、JavaScript 文件等静态资源。

3. In-Memory IndexedDB：使用 IndexedDB 数据库存储的离线缓存。该缓存存储在浏览器硬盘上，可以在离线状态下使用，并在用户关闭浏览器后仍然存在。它可以存储动态数据，以及静态资源。

4. Service Worker Cache：使用 Service Worker API 存储的离线缓存。该缓存存储在浏览器硬盘上，可以在离线状态下使用，并在用户关闭浏览器后仍然存在。它可以存储动态数据，以及静态资源。

5. Application Cache：使用 HTML5 的 Application Cache API 存储的离线缓存。该缓存存储在浏览器硬盘上，可以在离线状态下使用，并在用户关闭浏览器后仍然存在。它可以存储静态资源，以及静态页面。

6. HTTP Cache：存储在服务器或代理上的永久缓存。该缓存用于在多个用户间共享缓存，并且可以在多个浏览器或设备上共享。它可以存储静态资源，以及动态数据。

需要注意的是，所有缓存都有其生存期限，当缓存过期时，将会重新请求数据。此外，开发人员可以通过在 HTTP 请求头中设置缓存控制字段（如 Expires、Cache-Control、Etag 等），来控制浏览器的缓存行为。

**协商缓存 Last-Modified**

Last-Modified 是 HTTP 协议的一个响应头，表示请求资源的最后修改时间。

浏览器在请求一个资源时，会将上一次请求该资源时服务器返回的 Last-Modified 值一并发送给服务器，服务器根据该值决定是否返回资源的内容。

如果请求的资源在服务器端没有更改，那么服务器将返回一个 304 Not Modified 响应，并不返回资源的内容；否则服务器将返回完整的资源内容。

这样的协商缓存可以节省网络带宽，提高请求资源的速度。

## 10. Vue 里面 v-if 和 v-show 那个优先级高

v-if 和 v-show 是 Vue.js 中常用的指令，用于在界面上显示或隐藏元素。它们都可以根据某个表达式的值来决定是否显示。

Vue.js 2 和 Vue.js 3 中 v-if 与 v-show 的优先级是一样的，没有明显的差别。

不过，在使用时要注意：

v-if 是惰性的，只有在表达式的值为 true 时才创建元素；
v-show 则是立即显示/隐藏，通过控制元素的 display 属性实现；
因此，在需要频繁地显示/隐藏元素的场景中，使用 v-show 比 v-if 更好；在只需要一次性创建元素的场景中，使用 v-if 更合适。

## 11. hash 和 history 模式的实现原理

Vue Router 支持三种路由模式：

- Hash 模式：URL 中带有 #，使用 window.location.hash 进行路由跳转，默认模式。

- History 模式：URL 中不带 #，使用 HTML5 history API（history.pushState 和 history.replaceState）进行路由跳转。

- Abstract 模式：不支持 history.pushState 和 history.replaceState 的浏览器或 WebView 中使用。

---

Hash 模式：在 URL 中带有 # 符号的情况下，浏览器不会对 URL 进行请求，而是通过 JavaScript 监听 hashchange 事件，实现页面路由跳转。

History 模式：使用 HTML5 History API，可以模拟 URL 跳转，实现页面路由跳转。浏览器会发送请求，服务器返回正确的内容，支持前进和后退操作。

Abstract 模式：适用于不支持 HTML5 History API 的浏览器或者 WebView 环境，这种模式完全基于 JavaScript 进行路由跳转，不支持前进和后退操作，需要开发人员自己处理。

## 12. Vue 里面有一个父组件和子组件他们的生命周期钩子函数执行顺序

TodoList.vue

```vue
<template>
  <div class="todolist">
    <TodoItem></TodoItem>
  </div>
</template>
<script>
import TodoItem from '@/components/Todo/TodoItem';
export default {
  name: 'TodoList',
  components: {
    TodoItem
  },
  data() {
    return {};
  },
  beforeCreate() {
    console.log('TodoList beforeCreate');
  },
  created() {
    console.log('TodoList created');
  },
  beforeMount() {
    console.log('TodoList beforeMount');
  },
  mounted() {
    console.log('TodoList mounted');
  },
  beforeUpdate() {
    console.log('TodoList beforeUpdate');
  },
  updated() {
    console.log('TodoList updated');
  },
  beforeDestroy() {
    console.log('TodoList beforeDestroy');
  },
  destroyed() {
    console.log('TodoList destroyed');
  }
};
</script>
```

TodoItem.vue

```vue
<template>
  <div class="todoitem">todoitem</div>
</template>
<script>
export default {
  name: 'TodoItem',
  data() {
    return {};
  },
  beforeCreate() {
    console.log('TodoItem beforeCreate');
  },
  created() {
    console.log('TodoItem created');
  },
  beforeMount() {
    console.log('TodoItem beforeMount');
  },
  mounted() {
    console.log('TodoItem mounted');
  },
  beforeUpdate() {
    console.log('TodoItem beforeUpdate');
  },
  updated() {
    console.log('TodoItem updated');
  },
  beforeDestroy() {
    console.log('TodoItem beforeDestroy');
  },
  destroyed() {
    console.log('TodoItem destroyed');
  }
};
</script>
```

- 父组件 - TodoList beforeCreate
- 父组件 - TodoList created
- 父组件 - TodoList beforeMount
- 子组件 - TodoItem beforeCreate
- 子组件 - TodoItem created
- 子组件 - TodoItem beforeMount
- 子组件 - TodoItem mounted
- 父组件 - TodoList mounted

## 13. Vue 虚拟 DOM 是什么？

<a href="/frontend/230128-vue-interview-questions?id=_22-vue-的-virtual-dom-是什么？" target="_blank">Vue 的 Virtual DOM 是什么？</a>

https://cn.vuejs.org/guide/extras/rendering-mechanism.html#virtual-dom

## 14. 平时在开发中有没有封装一些自定义指令，比如：v-scroll 懒加载

**面试官：一屏幕有 10 个 DOM 10 条消息， 如何判断那一条消息需要发送已读回执**

## 15. 微任务和宏任务都有哪些？

**面试官：一个普通的 JavaScript 是宏任务还是微任务？比如变量声明**

## 16. fs 模块遍历文件夹，并且输出每一个文件的名称和路径，如何处理

## 17. Nodejs 里面什么是进程守护

1. nodemon
2. forever
3. pm2

## 18. Electron 问题，在开发的时候你主要负责主进程还是渲染进程

**面试官：你是如何和百度内容 exe 程序通信**

## 19. 最近做的 electron 版本是多少？6.12.1 升级 17.3

**面试官：已经到 21 版本了，为什么没有用 21 版本的内容**

## 20. 项目多空间切换 是业务模块还是什么定义

## 21. 全文检索, sqlite3 如何实现的

**消息是存储在本地吗？**

## 22. 加密方式使用的是哪种

## 23. 前端的 key 在哪里（公钥、私钥）

## 24. 如何使用 nodejs 查询别的应用启动路径

## 25. **实时获取到应用的安装和卸载**

Win32 API 可以用来监听 Windows 系统上应用安装和卸载事件，但需要通过一些第三方包才能在 Node.js 里面使用。可以使用 node-ffi 模块，该模块允许在 Node.js 里面调用 Windows API。具体实现方式可以参考示例代码和相关文档。

以下是一个使用 Node.js + win32api 实时监听系统安装/卸载事件的示例：

```javascript
const {Client} = require('node-wmi');
const wmi = new Client({username: 'Administrator', password: 'password'});

wmi.query('SELECT * FROM Win32_Product', function (err, result) {
  if (err) {
    console.error(err);
  } else {
    console.log(result);
  }
});

wmi.on('created', function (item) {
  console.log(item.Name + ' has been installed');
});

wmi.on('deleted', function (item) {
  console.log(item.Name + ' has been uninstalled');
});

wmi.on('changed', function (item) {
  console.log(item.Name + ' has been changed');
});
```

以上代码使用 Node.js 的 node-wmi 模块，通过监听 Win32_Product 的实例变化来实时获取应用的安装/卸载事件。

## 26. electron 签名和验证签名有了解吗

## 27. 代码题

题目 1

```js
console.log(1);
setTimeout(() => {
  console.log(2);
}, 0);

new Promise((resolve, reject) => {
  console.log(3);
  resolve();
})
  .then(() => {
    console.log(4);
  })
  .then(() => {
    console.log(5);
  });

console.log(6);
// 1
// 3
// 6
// 4
// 5
// 2
```

题目 2

```js
let a = {
  b: function () {
    console.log(this);
  },
  c: () => {
    console.log(this);
  }
};
a.b(); // a
a.c(); // window
```

题目 3

```js
for (let i = 0; i <= 3; i++) {
  setTimeout(() => {
    console.log(i);
  });
}

// 0
// 1
// 2
// 3
```

题目 4

```js
// "use strict"
function Foo() {
  getName = function () {
    console.log(1);
  };
  return this;
}

Foo.getName = function () {
  console.log(2);
};

Foo.prototype.getName = function () {
  console.log(3);
};

var getName = function () {
  console.log(4);
};

function getName() {
  console.log(5);
}

// 请填写输出结果
Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1 严格模式报错
getName(); // 1
new Foo.getName(); // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
```

## 28. 项目经理：React 和 Vue 底层的区别，关于数据 DOM 操作，如何去判断，原理有了解过吗

## 29. Vue2 和 Vue3 的区别

## 30. 项目经理：Vue2 和 Vue3 了解的差不多，,老项目是使用 Vue2 写的,现在希望对他进行升级,Api 和代码组织形式发生了一些变化，,如果想把 Vue2 升级到 Vue3 的话，有没有做过类似的事情

有插件是可以做得到的

## 31. 项目经理：刚刚听到你的阐述大部分都是正确的, 这样，结合一下，因为你既懂 Vue 又懂 React, 你可以了解这两个框架底层对于数据的处理, 到底是一个什么样的逻辑, 比如：Vue 是基于 watcher, React 是基于 JSON 在底层会有一个 json 做底层算法的对比, 它的每一个版本都会有一些变化, Vue2 会吸收一些 React 的知识, Vue3 又会吸收一些

## 32. 判断有网或者没有网 有没有做过

## 33. 项目经理：你放不方便你为什么从上一家公司离职

## 34. 项目经理：如果有机会合作的话, 对于未来的工作有什么期望或者规划

我：有的，

我想了解咱们公司是一个什么样的团队

我：一直是你问我
我希望了解一下公司团队、
公司模式、测试、流程和规模这些大概是什么样子的
