# 前端跨域通信：了解前端跨域通信的常用方法，如何使用跨域通信来实现功能。

## 什么是跨域？

浏览器的一个安全策略，域名、协议、端口号

## 了解前端跨域通信的常用方法

- 使用代理服务器：前端向代理服务器发起请求，代理服务器再向目标服务器发起请求，这样就可以实现跨域访问。
- 使用服务器端转发：前端向后端服务器发起请求，后端服务器再向目标服务器发起请求，这样就可以实现跨域访问。
- 使用 CORS（Cross-Origin Resource Sharing）：浏览器会在发送跨域请求时，向服务器发送一个预检请求，服务器返回允许跨域访问的响应头，浏览器再发送正式的请求。
- 使用 JSONP（JSON with Padding）：通过动态创建 script 标签的方式，在浏览器端加载远程脚本。
- 使用 postMessage：在不同源的窗口、框架、文件之间进行通信，使用 postMessage() 方法发送和接收消息。

### **1 和 2 有什么不一样**

使用代理服务器和使用服务器端转发两种方法都是通过在浏览器端和服务器端之间加入一个中间层来实现跨域访问的。

但是，它们有一些区别：

- 使用代理服务器时，前端向代理服务器发起请求，代理服务器再向目标服务器发起请求。这种方式适用于前端需要访问的服务器支持 CORS 的情况。
- 使用服务器端转发时，前端向后端服务器发起请求，后端服务器再向目标服务器发起请求。这种方式适用于前端需要访问的服务器不支持 CORS 的情况。

使用代理服务器或服务器端转发时，需要注意安全性和效率问题。

### **1 和 2 哪一种是反向代理**

使用代理服务器的方法可以使用反向代理来实现。

所谓反向代理，就是指以代理服务器为前端，将用户的请求转发给后端服务器，再将后端服务器的响应返回给用户。反向代理的作用包括负载均衡、流量控制、安全防护、缓存等。

使用服务器端转发的方法，并不是反向代理的方法。它的原理是，前端向后端服务器发起请求，后端服务器再向目标服务器发起请求，将请求结果返回给前端。使用服务器端转发的方法，适用于前端需要访问的服务器不支持 CORS 的情况。

## 如何使用跨域通信来实现功能

### 使用代理服务器

#### vite（vue2,vue3）

https://cn.vitejs.dev/config/server-options.html#server-proxy

#### vue-cli(webpack)

在 vue.config.js 中配置代理服务器：

```js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: process.env.VUE_APP_API_URL,
        changeOrigin: true,
        secure: false,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};
```

#### create-react-app

在 package.json 中配置代理服务器：

```JSON
{
  "proxy": {
    "/api": {
      "target": process.env.REACT_APP_API_URL,
      "changeOrigin": true,
      "secure": false,
      "pathRewrite": {
        "^/api": ""
      }
    }
  }
}

```

#### nuxt.js

在 nuxt.config.js 中配置代理服务器：

```js
module.exports = {
  serverMiddleware: [
    {
      path: '/api',
      handler: '~/api/index.js'
    }
  ],
  proxy: {
    '/api': {
      target: process.env.NUXT_ENV_API_URL,
      changeOrigin: true,
      secure: false,
      pathRewrite: {
        '^/api': ''
      }
    }
  }
};
```

#### nest.js

#### 在 `page/api/`目录下创建`[[...proxy]].ts`

```ts
import {NextApiRequest, NextApiResponse} from 'next';
import httpProxyMiddleware from 'next-http-proxy-middleware';

export const config = {
  api: {
    bodyParser: false
  }
};

const apiproxy = async (req: NextApiRequest, res: NextApiResponse) => {
  return httpProxyMiddleware(req, res, {
    target: process.env.NEXT_PUBLIC_API_URL,
    changeOrigin: true,
    secure: false,
    pathRewrite: [
      {
        patternStr: '^/api/',
        replaceStr: ''
      }
    ],
    onProxyInit: (proxy) => {
      /**
       * Check the list of bindable events in the `http-proxy` specification.
       * @see https://www.npmjs.com/package/http-proxy#listening-for-proxy-events
       */
      proxy.on('proxyReq', (proxyReq, req, res) => {});
      proxy.on('proxyRes', (proxyRes, req, res) => {});
    }
  });
};

export default apiproxy;
```

#### 在后端服务器端使用中间件代理：

在后端服务器端使用中间件代理，可以通过使用 http-proxy-middleware 或 http-proxy 库来实现。

例如，使用 http-proxy-middleware 库：

```js
const proxy = require('http-proxy-middleware');

app.use(
  '/api',
  proxy({
    target: process.env.API_URL,
    changeOrigin: true,
    secure: false,
    pathRewrite: {
      '^/api': ''
    }
  })
);
```

使用 http-proxy 库：

```js
const httpProxy = require('http-proxy');
const proxy = httpProxy.createProxyServer({});

app.use('/api', (req, res) => {
  proxy.web(req, res, {
    target: process.env.API_URL,
    changeOrigin: true,
    secure: false,
    pathRewrite: {
      '^/api': ''
    }
  });
});
```

#### nginx

nginx 是一个开源的、高性能的 HTTP 服务器和反向代理服务器，可以用来代理跨域请求。

要使用 nginx 代理跨域请求，需要在 nginx 配置文件中加入以下内容：

```conf
server {
  listen 80;
  server_name example.com;

  location /api {
    proxy_pass http://api.example.com;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
  }
}

```

这样，所有对 http://example.com/api 的请求都会被代理到 http://api.example.com。

注意：nginx 代理跨域请求时，需要注意安全性，避免被恶意攻击。

### 使用服务器端转发

在后端服务器端使用中间件实现转发，例如：

Express:

```js
const axios = require('axios');
const express = require('express');
const app = express();

app.use('/api', (req, res) => {
  axios
    .get(process.env.API_URL + req.url)
    .then((response) => res.send(response.data))
    .catch((error) => res.send(error));
});
```

### 使用 CORS（Cross-Origin Resource Sharing）

#### 方法 1 使用 cors 模块

下面设置仅仅开发环境使用 cors

```javascript
const cors = require('cors');

if (process.env.NODE_ENV !== 'production') {
  app.use(cors());
}
```

#### 方法 2 中间件

使用 CORS，需要在服务器端设置响应头，允许浏览器进行跨域访问。例如：

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});
```

### 使用 JSONP（JSON with Padding）

使用 JSONP，需要在服务器端生成脚本文件，并返回给浏览器。例如：

```JS
app.get('/api', (req, res) => {
  res.type('text/javascript');
  res.send(`${req.query.callback}(${JSON.stringify(data)})`);
});

```

### 使用 postMessage

使用 postMessage，需要在发送消息的窗口、框架、文件中调用 postMessage() 方法，并在接收消息的窗口、框架、文件中监听 message 事件。例如：

发送消息的窗口：

```js
window.parent.postMessage('Hello, Parent!', '*');
```

接收消息的窗口：

```JS
window.addEventListener('message', (event) => {
  console.log(event.data);
});

```

---

## 遇到的问题

### 项目运行起来很慢？

改用 vite

注意：有的配置 vite 和 webpack，要统一修改，如果是商业化的项目，不建议修改

### 为什么不建议老项目升级到 vite 工具？

成本，改完内容之后，出现问题谁负责？

改完内容，要求测试介入

## 如何让每一次的代理请求，都在控制台显示

logLevel: 'debug'

```js
 proxy: {
      // 配置跨域
      '/api': {
          target: 'https://example.com',
          ws: true,
          changeOrigin: true,
          logLevel: 'debug'
          // ,
          // pathRewrite: {
          //     '^/api': ''
          // }
      }
  }
```
